using Content.Client.UserInterface.Controls;
using Content.Client.UserInterface.Fragments;
using Content.Shared.Mech.Components;
using Content.Shared.Mech;
using Content.Shared.Atmos;
using Content.Shared.Mech.Equipment.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;
using System.Linq;
using Robust.Client.UserInterface;
using Content.Shared.Mech.EntitySystems;

namespace Content.Client.Mech.Ui;

/// <summary>
/// Interface control for mechs.
/// </summary>
/// <seealso cref="MechBoundUserInterface"/>
[GenerateTypedNameReferences]
public sealed partial class MechMenu : FancyWindow
{
    // Dependencies
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly ILocalizationManager _loc = default!;

    // State
    private EntityUid _mech;
    private bool _hasAccess = true;
    private bool _pilotPresent = false;

    // Events for the BUI to subscribe to
    public event Action<EntityUid>? OnRemoveButtonPressed;
    public event Action<EntityUid>? OnRemoveModuleButtonPressed;
    public event Action? OnAccessDeniedAttempt;

    public event Action<bool>? OnAirtightChanged;
    public event Action<bool>? OnFanToggle;
    public event Action<bool>? OnFilterToggle;
    public event Action? OnDnaLockRegister;
    public event Action? OnDnaLockToggle;
    public event Action? OnDnaLockReset;
    public event Action? OnCardLockRegister;
    public event Action? OnCardLockToggle;
    public event Action? OnCardLockReset;
    public event Action? OnCabinPurge;

    public MechMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        InitializeEventHandlers();
    }

    public void SetEntity(EntityUid entity)
    {
        _mech = entity;

        this.SetInfoFromEntity(_entityManager, _mech);

        MechView.SetEntity(entity);
    }

    private void InitializeEventHandlers()
    {
        // Cabin controls with access checks
        AirtightButton.OnToggled += args => ExecuteWithAccessCheck(() => OnAirtightChanged?.Invoke(args.Pressed));
        CabinPurgeButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnCabinPurge?.Invoke());

        // Fan controls
        FanToggle.StateChanged += isOn => ExecuteWithAccessCheck(() => OnFanToggle?.Invoke(isOn));

        // Lock controls
        DnaLockRegisterButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnDnaLockRegister?.Invoke());
        DnaLockBlockButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnDnaLockToggle?.Invoke());
        DnaLockResetButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnDnaLockReset?.Invoke());

        CardLockRegisterButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnCardLockRegister?.Invoke());
        CardLockBlockButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnCardLockToggle?.Invoke());
        CardLockResetButton.OnPressed += _ => ExecuteWithAccessCheck(() => OnCardLockReset?.Invoke());

        // Filter control
        FilterEnabledCheck.OnToggled += args => ExecuteWithAccessCheck(() => OnFilterToggle?.Invoke(args.Pressed));
    }

    private void ExecuteWithAccessCheck(Action action)
    {
        if (CheckAccess())
        {
            action();
        }
        else
        {
            OnAccessDeniedPing();
        }
    }

    private void OnAccessDeniedPing()
    {
        OnAccessDeniedAttempt?.Invoke();
    }

    private bool CheckAccess()
    {
        // Check if mech is locked and user has access
        var isLocked = _lastState?.IsLocked ?? false;
        var hasAccess = _hasAccess;

        // If no UI state available, assume access is granted
        if (_lastState == null)
            return true;

        // If mech is not locked, access is granted
        if (!isLocked)
            return true;

        // If mech is locked, check if user has access
        return hasAccess;
    }

    public void UpdateMechStats()
    {
        // Use data from UI state if available, otherwise fall back to component data
        if (_lastState != null)
        {
            // Update integrity display
            if (_lastState.MaxIntegrity > 0f)
            {
                var integrityPercent = _lastState.Integrity / _lastState.MaxIntegrity;
                IntegrityDisplayBar.Value = integrityPercent;
                IntegrityDisplay.Text = _loc.GetString("mech-integrity-display", ("amount", (int)(integrityPercent * 100)));
            }
            else
            {
                IntegrityDisplayBar.Value = 0f;
                IntegrityDisplay.Text = _loc.GetString("mech-integrity-display", ("amount", 0));
            }

            // Update energy display
            if (_lastState.MaxEnergy > 0f)
            {
                var energyPercent = _lastState.Energy / _lastState.MaxEnergy;
                EnergyDisplayBar.Value = energyPercent;
                EnergyDisplay.Text = _loc.GetString("mech-energy-display", ("amount", (int)(energyPercent * 100)));
            }
            else
            {
                EnergyDisplayBar.Value = 0f;
                EnergyDisplay.Text = _loc.GetString("mech-energy-missing");
            }

            // Update equipment slot display
            SlotDisplay.Text = _loc.GetString("mech-equipment-slot-display",
                ("used", _lastState.EquipmentUsed), ("max", _lastState.MaxEquipmentAmount));

            // Update module capacity display
            ModuleSlotDisplay.Text = _loc.GetString("mech-module-slot-display",
                ("used", _lastState.ModuleSpaceUsed), ("max", _lastState.ModuleSpaceMax));
        }
        else
        {
            // Fallback to component data if no UI state available
            if (!_entityManager.TryGetComponent<MechComponent>(_mech, out var mechComp))
                return;

            var integrityPercent = mechComp.Integrity / mechComp.MaxIntegrity;
            IntegrityDisplayBar.Value = integrityPercent.Float();
            IntegrityDisplay.Text = _loc.GetString("mech-integrity-display", ("amount", (int)(integrityPercent * 100)));

            if (mechComp.MaxEnergy != 0f)
            {
                var energyPercent = mechComp.Energy / mechComp.MaxEnergy;
                EnergyDisplayBar.Value = energyPercent.Float();
                EnergyDisplay.Text = _loc.GetString("mech-energy-display", ("amount", (int)(energyPercent * 100)));
            }
            else
            {
                EnergyDisplayBar.Value = 0f;
                EnergyDisplay.Text = _loc.GetString("mech-energy-missing");
            }

            var equipUsed = mechComp.EquipmentContainer.ContainedEntities.Count;
            SlotDisplay.Text = _loc.GetString("mech-equipment-slot-display",
                ("used", equipUsed), ("max", mechComp.MaxEquipmentAmount));

            // Module capacity label uses consumed space out of total
            var usedSpace = 0;
            foreach (var ent in mechComp.ModuleContainer.ContainedEntities)
                usedSpace += _entityManager.GetComponentOrNull<MechModuleComponent>(ent)?.Size ?? 1;
            ModuleSlotDisplay.Text = _loc.GetString("mech-module-slot-display",
                ("used", usedSpace), ("max", mechComp.MaxModuleSpace));
        }
    }

    public void UpdateMechState(MechBoundUiState state)
    {
        _lastState = state;
        _pilotPresent = state.PilotPresent;

        // Update access state immediately to prevent UI flickering
        _hasAccess = state.HasAccess;

        // Toggle fan controls visibility based on module presence
        FanToggle.Visible = state.HasFanModule;
        FanStatusLabel.Visible = state.HasFanModule;
        FilterEnabledCheck.Visible = state.HasFanModule;
        FanMissingLabel.Visible = !state.HasFanModule;

        CabinPurgeButton.Text = _loc.GetString("mech-cabin-purge");
        CabinPurgeButton.Disabled = !state.CabinPurgeAvailable;

        // Update airtight button state
        if (AirtightButton.Pressed != state.IsAirtight)
            AirtightButton.Pressed = state.IsAirtight;

        // Update fan button states
        if (state.HasFanModule)
        {
            if (FanToggle.IsOn != state.FanActive)
                FanToggle.IsOn = state.FanActive;

            if (FilterEnabledCheck.Pressed != state.FilterEnabled)
                FilterEnabledCheck.Pressed = state.FilterEnabled;
        }

        // Update cabin gas level (always show)
        CabinGasLabel.Text = _loc.GetString("mech-cabin-pressure-level", ("level", $"{state.CabinGasLevel:F1}"));

        // Update tank pressure (or N/A if no cylinder)
        if (state.HasGasModule)
            TankPressureLabel.Text = _loc.GetString("mech-tank-pressure-level", ("state", "ok"), ("pressure", state.TankPressure.ToString("0.##")));
        else
            TankPressureLabel.Text = _loc.GetString("mech-tank-pressure-level", ("state", "na"));

        // Update fan status display
        UpdateFanStatusDisplay(state.FanState);

        // Update lock information and buttons
        UpdateLockInfoLabels(state);
        UpdateLockButtons(state);

        // Update equipment and module views
        UpdateEquipmentView(state.Equipment);
        UpdateModuleView(state.Modules);

        // Ensure access state is properly applied
        var isLocked = state.IsLocked;
        var noAccessActive = isLocked && !state.HasAccess;
        SettingsGrid.Visible = !noAccessActive;
        SettingsNoAccessPanel.Visible = noAccessActive;

        // Update remove buttons state for equipment and modules
        var disableRemove = _pilotPresent || (isLocked && !state.HasAccess);
        foreach (var control in EquipmentControlContainer.Children.OfType<MechEquipmentControl>())
        {
            control.SetRemoveDisabled(disableRemove);
        }
        foreach (var control in ModuleControlContainer.Children.OfType<MechEquipmentControl>())
        {
            control.SetRemoveDisabled(disableRemove);
        }
    }

    private void UpdateFanStatusDisplay(MechFanState fanState)
    {
        var stateKey = fanState switch
        {
            MechFanState.Off => "off",
            MechFanState.On => "on",
            MechFanState.Idle => "idle"
        };
        var stateColorKey = fanState switch
        {
            MechFanState.Off => Color.Red,
            MechFanState.On => Color.Green,
            MechFanState.Idle => Color.Yellow
        };

        FanStatusLabel.Text = _loc.GetString("mech-fan-status", ("state", stateKey));
        FanStatusLabel.FontColorOverride = stateColorKey;
    }

    private void UpdateLockInfoLabels(MechBoundUiState state)
    {
        // Update DNA lock info
        if (state.DnaLockRegistered && !string.IsNullOrEmpty(state.OwnerDna))
        {
            DnaLockInfoLabel.Text = _loc.GetString("mech-lock-dna-info", ("dna", state.OwnerDna));
        }
        else
        {
            DnaLockInfoLabel.Text = _loc.GetString("mech-lock-not-set");
        }

        // Update Card lock info
        if (state.CardLockRegistered && !string.IsNullOrEmpty(state.OwnerJobTitle))
        {
            CardLockInfoLabel.Text = _loc.GetString("mech-lock-card-info", ("name", state.OwnerJobTitle));
        }
        else
        {
            CardLockInfoLabel.Text = _loc.GetString("mech-lock-not-set");
        }
    }

    private void UpdateLockButtons(MechBoundUiState state)
    {
        var (dnaRegistered, dnaActive, _) = GetLockState(state, MechLockType.Dna);
        var (cardRegistered, cardActive, _) = GetLockState(state, MechLockType.Card);

        // DNA Lock Buttons
        DnaLockRegisterButton.Visible = !dnaRegistered;
        DnaLockBlockButton.Visible = dnaRegistered;
        DnaLockResetButton.Visible = dnaRegistered;
        DnaLockBlockButton.Text = _loc.GetString(dnaActive ? "mech-lock-deactivate" : "mech-lock-activate");
        DnaLockBlockButton.Pressed = dnaActive;

        // Card Lock Buttons
        CardLockRegisterButton.Visible = !cardRegistered;
        CardLockBlockButton.Visible = cardRegistered;
        CardLockResetButton.Visible = cardRegistered;
        CardLockBlockButton.Text = _loc.GetString(cardActive ? "mech-lock-deactivate" : "mech-lock-activate");
        CardLockBlockButton.Pressed = cardActive;
    }

    private MechBoundUiState? _lastState;

    public void OverrideAccessAndRefresh(bool hasAccess)
    {
        _hasAccess = hasAccess;
        if (_lastState != null)
        {
            var isLocked = _lastState.IsLocked;
            var noAccessActive = isLocked && !_hasAccess;
            SettingsGrid.Visible = !noAccessActive;
            SettingsNoAccessPanel.Visible = noAccessActive;
        }
    }

    private (bool IsRegistered, bool IsActive, string? OwnerId) GetLockState(MechBoundUiState state, MechLockType lockType)
    {
        return lockType switch
        {
            MechLockType.Dna => (state.DnaLockRegistered, state.DnaLockActive, state.OwnerDna),
            MechLockType.Card => (state.CardLockRegistered, state.CardLockActive, state.OwnerJobTitle),
            _ => (false, false, null)
        };
    }

    private (bool IsRegistered, bool IsActive, string? OwnerId) GetCurrentLockState(MechLockType lockType)
    {
        if (_lastState == null)
            return (false, false, null);

        return GetLockState(_lastState, lockType);
    }

    public void UpdateEquipmentView(List<NetEntity>? equipment = null)
    {
        UpdateEntityListView<MechEquipmentComponent>(
            equipment,
            EquipmentControlContainer,
            mech => mech.EquipmentContainer.ContainedEntities,
            ent => _entityManager.GetComponentOrNull<MechEquipmentComponent>(ent)?.Size ?? 1,
            ent => OnRemoveButtonPressed?.Invoke(ent),
            null
        );
    }

    public void UpdateModuleView(List<NetEntity>? modules = null)
    {
        UpdateEntityListView<MechModuleComponent>(
            modules,
            ModuleControlContainer,
            mech => mech.ModuleContainer.ContainedEntities,
            ent => _entityManager.GetComponentOrNull<MechModuleComponent>(ent)?.Size ?? 1,
            ent => OnRemoveModuleButtonPressed?.Invoke(ent),
            null
        );
    }

    private void UpdateEntityListView<TComponent>(
        List<NetEntity>? entities,
        BoxContainer container,
        Func<MechComponent, IEnumerable<EntityUid>> getEntities,
        Func<EntityUid, int> getSize,
        Action<EntityUid> onRemove,
        Func<EntityUid, Control?>? getFragment = null)
        where TComponent : class
    {
        if (entities == null)
        {
            if (!_entityManager.TryGetComponent<MechComponent>(_mech, out var mechComp))
                return;
            entities = new List<NetEntity>();
            foreach (var ent in getEntities(mechComp))
                entities.Add(_entityManager.GetNetEntity(ent));
        }

        // Update existing controls instead of recreating them
        var existingControls = container.Children.OfType<MechEquipmentControl>().ToList();
        var entityToControl = new Dictionary<EntityUid, MechEquipmentControl>();

        foreach (var control in existingControls)
        {
            if (control.Entity != EntityUid.Invalid)
                entityToControl[control.Entity] = control;
        }

        // Remove controls for entities that no longer exist
        var currentEntities = entities.Select(e => _entityManager.GetEntity(e)).ToHashSet();
        foreach (var control in existingControls)
        {
            if (!currentEntities.Contains(control.Entity))
            {
                container.Children.Remove(control);
            }
        }

        // Update or create controls for current entities
        foreach (var netEnt in entities)
        {
            var ent = _entityManager.GetEntity(netEnt);
            if (!_entityManager.TryGetComponent<MetaDataComponent>(ent, out var metaData))
                continue;

            if (entityToControl.TryGetValue(ent, out var existingControl))
            {
                // Update existing control
                var size = getSize(ent);
                var fragment = getFragment?.Invoke(ent);
                existingControl.UpdateControl(metaData.EntityName, fragment, size);
            }
            else
            {
                // Create new control
                var size = getSize(ent);
                var fragment = getFragment?.Invoke(ent);
                var control = new MechEquipmentControl(ent, metaData.EntityName, fragment, size);
                var entityToRemove = ent;
                control.OnRemoveButtonPressed += () => onRemove(entityToRemove);
                container.AddChild(control);
            }
        }

        // Update disabled state for all controls
        var isLocked = _lastState?.IsLocked ?? false;
        var hasAccess = _lastState?.HasAccess ?? true;
        var disableRemove = _pilotPresent || (isLocked && !hasAccess);

        foreach (var control in container.Children.OfType<MechEquipmentControl>())
        {
            control.SetRemoveDisabled(disableRemove);
        }
    }

    /// <summary>
    /// Updates the UI state and refreshes all displays.
    /// </summary>
    public void UpdateState(MechBoundUiState state)
    {
        UpdateMechState(state);
        UpdateMechStats();
        UpdateEquipmentView(state.Equipment);
        UpdateModuleView(state.Modules);

        // Ensure access state is properly applied after all updates
        var isLocked = state.IsLocked;
        var noAccessActive = isLocked && !state.HasAccess;
        SettingsGrid.Visible = !noAccessActive;
        SettingsNoAccessPanel.Visible = noAccessActive;
    }
}
