using System.Numerics;
using Content.Client.UserInterface.Controls;
using Content.Shared.Administration;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.SpecializationConsole.Controls;

/// <summary>
/// Client-side dialog with multiple prompts.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class MonotoneDialogWindow : BaseWindow
{
    /// <summary>
    /// Action for when the ok button is pressed or the last field has enter pressed.
    /// Results maps prompt FieldIds to the LineEdit's text contents.
    /// </summary>
    public Action<Dictionary<string, string>>? OnConfirmed;

    /// <summary>
    /// Action for when the cancel button is pressed or the window is closed.
    /// </summary>
    public Action? OnCancelled;

    /// <summary>
    /// Used to ensure that only one output action is invoked.
    /// E.g. Pressing cancel will invoke then close the window, but OnClose will not invoke.
    /// </summary>
    private bool _finished;

    private List<(string, LineEdit)>? _promptLines;

    private readonly int _maxLength;

    public MonotoneDialogWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        CloseButton.OnPressed += _ => Close();
        OkButton.OnPressed += _ => Confirm();

        CancelButton.OnPressed += _ =>
        {
            _finished = true;
            OnCancelled?.Invoke();
            Close();
        };
        OnClose += () =>
        {
            if (!_finished)
                OnCancelled?.Invoke();
        };
    }

    public MonotoneDialogWindow(List<QuickDialogEntry> entries, int maxLength, bool ok = true, bool cancel = true) : this()
    {
        OkButton.Visible = ok;
        CancelButton.Visible = cancel;

        _promptLines = new(entries.Count);
        _maxLength = maxLength;

        for (var i = 0; i < entries.Count; i++)
        {
            var entry = entries[i];

            var box = new BoxContainer();
            box.AddChild(new Label { Text = entry.Prompt, HorizontalExpand = true, SizeFlagsStretchRatio = 0.5f });

            var edit = new LineEdit { HorizontalExpand = true, Margin = new Thickness(5) };

            (Func<string, bool>, string) pair = entry.Type switch
            {
                QuickDialogEntryType.Integer => (VerifyInt, "integer"),
                QuickDialogEntryType.Float => (VerifyFloat, "float"),
                QuickDialogEntryType.ShortText => (VerifyShortText, "short-text"),
                QuickDialogEntryType.LongText => (VerifyLongText, "long-text"),
                _ => throw new ArgumentOutOfRangeException()
            };
            var (valid, name) = pair;

            edit.IsValid += valid;
            edit.PlaceHolder = entry.Placeholder ?? Loc.GetString($"quick-dialog-ui-{name}");
            edit.OnTextChanged += _ => OnTextChanged(edit);

            if (i == entries.Count - 1)
                edit.OnTextEntered += _ => Confirm();

            _promptLines.Add((entry.FieldId, edit));
            box.AddChild(edit);
            Prompts.AddChild(box);
        }

        MinWidth *= 2;
        OpenCentered();
    }

    private void OnTextChanged(LineEdit edit)
    {
        if (edit.Text.Length <= _maxLength)
            return;
        edit.Text = edit.Text.Remove(_maxLength);
        edit.CursorPosition = _maxLength;
    }

    protected override void Opened()
    {
        base.Opened();

        // Grab keyboard focus for the first dialog entry
        _promptLines?[0].Item2.GrabKeyboardFocus();
    }

    private void Confirm()
    {
        var results = new Dictionary<string, string>();
        if (_promptLines != null)
        {
            foreach (var (field, edit) in _promptLines)
            {
                results[field] = edit.Text;
            }
        }

        _finished = true;
        OnConfirmed?.Invoke(results);
        Close();
    }

    #region Input validation

    private bool VerifyInt(string input)
    {
        return int.TryParse(input, out var _);
    }

    private bool VerifyFloat(string input)
    {
        return float.TryParse(input, out var _);
    }

    private bool VerifyShortText(string input)
    {
        return input.Length <= 100;
    }

    private bool VerifyLongText(string input)
    {
        return input.Length <= 2000;
    }

    #endregion

    protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
    {
        return DragMode.Move;
    }
}
